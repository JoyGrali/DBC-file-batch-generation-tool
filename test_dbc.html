<!DOCTYPE html>
<html>
<head>
    <title>DBC Test</title>
</head>
<body>
    <h1>DBC文件测试</h1>
    <button onclick="testDBC()">测试DBC生成</button>
    <pre id="output"></pre>
    
    <script>
        // 创建一个简化的DBCEditor实例用于测试
        class TestDBCEditor {
            constructor() {
                this.fields = [
                    { 
                        name: '板卡类型', 
                        bits: 4, 
                        segments: [{position: 20, bits: 4}], 
                        description: '设备板卡类型',
                        usedForBatch: false,
                        abbreviation: 'BT'
                    },
                    { 
                        name: '通道编号', 
                        bits: 8, 
                        segments: [{position: 12, bits: 8}], 
                        description: '通道编号',
                        usedForBatch: true,
                        batchRange: {min: 0, max: 15},
                        abbreviation: 'CH'
                    }
                ];
                this.messages = [{
                    id: 'message_1',
                    name: 'Test_Message',
                    length: 8,
                    node: 'ECU1',
                    description: '测试报文',
                    signals: [{
                        name: 'TestSignal',
                        startBit: 0,
                        length: 8,
                        type: 'unsigned',
                        factor: 1,
                        offset: 0,
                        min: 0,
                        max: 255,
                        unit: '',
                        description: '测试信号',
                        byteOrder: 'lsb'
                    }],
                    functionCode: 1
                }];
                this.generatedMessages = [];
            }
            
            // DBC标识符清理函数
            cleanDBCIdentifier(str) {
                if (!str) return 'DefaultName';
                // 移除非法字符，只保留字母、数字和下划线
                return str.toString().replace(/[^a-zA-Z0-9_]/g, '_').replace(/^[^a-zA-Z_]/, '_');
            }
            
            // DBC字符串清理函数
            cleanDBCString(str) {
                if (!str) return '';
                // 转义双引号并移除控制字符
                return str.toString().replace(/"/g, '\\"').replace(/[\r\n\t]/g, ' ').trim();
            }
            
            // 数值验证函数
            validateNumber(value, min = 0, max = Number.MAX_SAFE_INTEGER) {
                const num = parseFloat(value);
                if (isNaN(num)) return min;
                return Math.max(min, Math.min(max, num));
            }
            
            // 获取所有当前报文信息
            getAllCurrentMessages() {
                return this.messages.map((message, index) => {
                    return {
                        id: 0x123,
                        name: message.name,
                        length: message.length,
                        node: message.node,
                        description: message.description,
                        signals: message.signals
                    };
                });
            }

            // 生成DBC文件内容
            generateDBCContent() {
                let dbcContent = `VERSION ""


NS_ : 
\tNS_DESC_
\tCM_
\tBA_DEF_
\tBA_
\tVAL_
\tCAT_DEF_
\tCAT_
\tFILTER
\tBA_DEF_DEF_
\tEV_DATA_
\tENVVAR_DATA_
\tSGTYPE_
\tSGTYPE_VAL_
\tBA_DEF_SGTYPE_
\tSIG_VALTYPE_
\tBA_SGTYPE_
\tSIG_GROUP_
\tSIGTYPE_VALTYPE_
\tBO_TX_BU_
\tBA_DEF_REL_
\tBA_REL_
\tBA_DEF_DEF_REL_
\tBU_SG_REL_
\tBU_EV_REL_
\tBU_BO_REL_
\tSG_MUL_VAL_

BS_:

BU_:`;

                const messages = this.generatedMessages.length > 0 ? this.generatedMessages : this.getAllCurrentMessages();
                
                // 收集所有用到的节点名称
                const nodeNames = new Set();
                messages.forEach(message => {
                    if (message.node) {
                        nodeNames.add(this.cleanDBCIdentifier(message.node));
                    }
                });
                
                // 添加BU_节点定义（紧接在BU_:后面，不要多余空行）
                if (nodeNames.size > 0) {
                    dbcContent += ' ' + Array.from(nodeNames).join(' ') + '\n\n';
                } else {
                    dbcContent += '\n\n';
                }

                messages.forEach(message => {
                    // 验证和清理报文数据
                    const messageId = this.validateNumber(message.id, 0, 0x1FFFFFFF);
                    const messageName = this.cleanDBCIdentifier(message.name);
                    const messageLength = this.validateNumber(message.length, 1, 8);
                    const messageNode = this.cleanDBCIdentifier(message.node);
                    
                    dbcContent += `BO_ ${messageId} ${messageName}: ${messageLength} ${messageNode}\n`;
                    
                    if (message.signals && message.signals.length > 0) {
                        message.signals.forEach(signal => {
                            // 验证和清理信号数据
                            const signalName = this.cleanDBCIdentifier(signal.name);
                            const startBit = this.validateNumber(signal.startBit, 0, 63);
                            const length = this.validateNumber(signal.length, 1, 64);
                            const factor = this.validateNumber(signal.factor, -1e10, 1e10) || 1;
                            const offset = this.validateNumber(signal.offset, -1e10, 1e10) || 0;
                            const min = this.validateNumber(signal.min, -1e10, 1e10) || 0;
                            const max = this.validateNumber(signal.max, -1e10, 1e10) || 0;
                            const unit = this.cleanDBCString(signal.unit);
                            
                            // 字节序：1=小端(Intel)，0=大端(Motorola)
                            const byteOrder = (signal.byteOrder === 'msb') ? '0' : '1';
                            const valueType = (signal.type === 'signed') ? '-' : '+';
                            
                            dbcContent += ` SG_ ${signalName} : ${startBit}|${length}@${byteOrder}${valueType} (${factor},${offset}) [${min}|${max}] "${unit}" ${messageNode}\n`;
                        });
                    }
                    
                    dbcContent += '\n';
                });

                // 添加信号注释
                messages.forEach(message => {
                    if (message.signals && message.signals.length > 0) {
                        message.signals.forEach(signal => {
                            if (signal.description && signal.description.trim()) {
                                const messageId = this.validateNumber(message.id, 0, 0x1FFFFFFF);
                                const signalName = this.cleanDBCIdentifier(signal.name);
                                const description = this.cleanDBCString(signal.description);
                                dbcContent += `CM_ SG_ ${messageId} ${signalName} "${description}";\n`;
                            }
                        });
                    }
                });

                return dbcContent;
            }
        }
        
        function testDBC() {
            try {
                const editor = new TestDBCEditor();
                const dbcContent = editor.generateDBCContent();
                
                document.getElementById('output').textContent = dbcContent;
                
                // 模拟下载文件
                const blob = new Blob([dbcContent], { type: 'text/plain;charset=utf-8' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = 'test_output.dbc';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
                
                console.log('DBC文件已生成并下载');
            } catch (error) {
                document.getElementById('output').textContent = 'Error: ' + error.message;
                console.error('生成DBC文件时出错:', error);
            }
        }
    </script>
</body>
</html>